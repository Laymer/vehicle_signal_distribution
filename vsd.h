// Copyright (C) 2018, Jaguar Land Rover
// This program is licensed under the terms and conditions of the
// Mozilla Public License, version 2.0.  The full text of the
// Mozilla Public License is at https://www.mozilla.org/MPL/2.0/
//
// Author: Magnus Feuer (mfeuer1@jaguarlandrover.com)
//

#include <stdint.h>
#include <rmc_list.h>

typedef enum {
    vsd_int8 = 0,
    vsd_uint8 = 1,
    vsd_int16 = 2,
    vsd_uint16 = 3,
    vsd_int32 = 4,
    vsd_uint32 = 5,
    vsd_double = 6,
    vsd_float = 7,
    vsd_boolean = 8,
    vsd_string = 9,
    vsd_stream = 10,
    vsd_na = 11,
} vsd_data_type_e;

typedef enum {
    vsd_attribute = 0,
    vsd_branch = 1,
    vsd_sensor = 2,
    vsd_actuator = 3,
    vsd_rbranch = 4,
    vsd_element = 5,
} vsd_elem_type_e;

typedef union {
    int8_t i8;
    uint8_t u8;
    int16_t i16;
    uint16_t u16;
    int32_t i32;
    uint32_t u32;
    double d;
    float f;
    uint8_t b;
    struct {
        char* data;
        uint32_t len;
        uint32_t allocated;
    } s;
} vsd_data_u;

typedef struct vsd_context vsd_context_t;
typedef struct vsd_desc vsd_desc_t;
typedef struct vsd_desc_branch vsd_desc_branch_t;
typedef uint32_t vsd_id_t;
typedef void (*vsd_subscriber_cb_t)(struct vsd_desc*);


RMC_LIST(vsd_desc_list, vsd_desc_node, struct vsd_desc*)
typedef vsd_desc_list vsd_desc_list_t;
typedef vsd_desc_node vsd_desc_node_t;


// Find a signal descriptor by its path name
// "Vehicle.Drivetrain.FuelSystem.TankCapacity" If parent_desc != 0,
// then search from that descriptor downard.  If parent_desc == 0,
// then use context->root as the starting point *result is set to the
// found descriptor, or 0 if not found
//
// Return
//  0 - Descriptor returnedc
//  ENOENT - One or more components in the path are missing.
//  ENODIR - One or more components in the path are not branches.
extern int vsd_find_desc_by_path(struct vsd_context* context,
                                         struct vsd_desc* parent_desc,
                                         char* path,
                                         struct vsd_desc** result);

// Find a signal descriptor by its signal ID.
//
// Return
//  0 - Descriptor returnedc
//  ENOENT - One or more components in the path are missing.
extern int vsd_find_desc_by_id(struct vsd_context* context,
                                       vsd_id_t id,
                                       struct vsd_desc** result);

// Set the value of a signal
// If the signal descriptor is a string, then a copy of val.data will be made
// and stored in desc.
//
// Please note that it is up to the caller to ensure that val is of the same type
// as the descriptor data type.
//
// Return:
//  0 - Value set.
//  EISDIR - Desc points to a branch.
//
// FIXME: Validate that val is legal if desc is enumerated.
// FIXME: Validate that val is not greater than maximum allowed value, if specified.
// FIXME: Validate that val is not less than minimum allowed value, if specified.
extern int vsd_set_value(struct vsd_desc* desc,
                                 vsd_data_u val);

// Set an active context to be used when a signal is received.
// The context defines signal definitions loaded from a VSS CSV file, callbacks, current
// signal values, etc.
// ctx is returned by a prior call to vsd_load_from_file();
//
extern void vsd_set_active_context(vsd_context_t* ctx);

// Return a pointer to the list hosting all children of parent.
// Return 0 if parent is not a branch.
extern vsd_desc_list_t* vsd_get_children(struct vsd_desc* parent);

// Load a signal tree from a CSV file./
// The file is generated by github.com/GENIVI/vehicle_signal_specification
// Please note that the CSV file must have signal IDs defined for branches.
// This can be checked by verifying that the second field in the CSV file
// always contains a number.
extern int vsd_load_from_file(struct vsd_context** context, char *fname);

// Convert the given string type to a data type.
// Return vsd_na if conversion was not possible./
extern vsd_data_type_e vsd_string_to_data_type(char* type);

// Convert the given data type to a printable string
extern char* vsd_data_type_to_string(vsd_data_type_e type);

// Convert the given string type to an element type.
// Return vsd_na (from vsd_data_type_e) if conversion
// was not possible.
extern vsd_elem_type_e vsd_string_to_elem_type(char* type);

// Convert the given element type to a printable string
extern char* vsd_elem_type_to_string(vsd_elem_type_e type);

// Install the full path to desc into buf.
// If the path is longer than buf_len characters, only buf_len - 1
// characters will be installed.
// buf will always be null terminated.
extern int vsd_desc_to_path(struct vsd_desc* desc, char* buf, int buf_len);
// Install the full path to desc into a static buf and return it./
// If the path is longer than 1024 bytes, the string
// "[signal path too long]" will be returned.
extern char* vsd_desc_to_path_static(struct vsd_desc* desc);

// Convert the provided string into a signal data element.
// The string is converted according to the type specified in 'type'.
// If conversion cannot be done, a default value is provided.
// Return -
//  0 - OK
//  EINVAL - The data type in 'type' is not supported.
//
extern int vsd_string_to_data(vsd_data_type_e type,
                                      char* str,
                                      vsd_data_u* res);

// Publish the signal(s) in desc.
// If desc is a branch, all signals installed under it will be published atomically.
// Unchanged values will be published as well.
extern int vsd_publish(struct vsd_desc* desc);

// Subscribe to signal updates in desc
// If desc is a branch, any updates made to a signal under desc will be reported
// to the callback.
// If an unchanged value is received, it will still trigger a callback.
//
extern int vsd_subscribe(struct vsd_context* ctx,
                                 struct vsd_desc* desc,
                                 vsd_subscriber_cb_t callback);

// Unsubscribe to a descriptor previously subscribed to
extern int vsd_unsubscribe(struct vsd_context* ctx,
                                   struct vsd_desc* desc,
                                   vsd_subscriber_cb_t callback);

// Return the element type of desc.
extern vsd_elem_type_e vsd_elem_type(vsd_desc_t* desc);

// Return the dfata type of desc.
extern vsd_data_type_e vsd_data_type(vsd_desc_t* desc);

// Return the name type of desc.
extern char* vsd_name(vsd_desc_t* desc);

// Return the id  of desc.
extern vsd_id_t vsd_id(vsd_desc_t* desc);

// Return the current value of desc.
extern vsd_data_u vsd_value(vsd_desc_t* desc);

// Return the minimum allowed value to the signal, if specified
extern vsd_data_u vsd_min(vsd_desc_t* desc);

// Return the maximum allowed value to the signal, if specified
extern vsd_data_u vsd_max(vsd_desc_t* desc);
